#!/usr/bin/env node
// vim: ai:ts=2:sw=2:et:syntax=javascript

(function() {
  "use strict";
  var Q = require('q');
  Q.longStackSupport = true;
  var Emptyc = require('../lib/emptyc');
  var path = require("path");
  var fs = require("fs");
  var dire = require("dire");
  var emptyc = new Emptyc();
  var NodeCache = require("node-cache");
  var mkdirp = require('mkdirp');

  var homepath = process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'];
  var configpath = path.join(homepath, ".empty.conf");
  var configpath2 = path.join(homepath, ".emptyc.conf");
  var cachepath = path.join(process.env.XDG_CACHE_HOME || path.join(homepath, ".cache"), "emptyc");

  mkdirp.sync(cachepath);

  var applyconf = function(data) {
    var user_config = JSON.parse(data);
    var merge = function merge(target, source)
    {
      for (var k in source)
      {
        if ((target[k] instanceof Object) && (source[k] instanceof Object))
          merge(target[k], source[k]);
        else
          target[k] = source[k];
      }
    };
    merge(emptyc.config, user_config);
  };

  var finalizers = [];
  var modules = {};

  Q.resolve()
    .then(function() { return Q.nfcall(fs.readFile, configpath, "utf-8").then(applyconf, function(){}); })
    .then(function() { return Q.nfcall(fs.readFile, configpath2, "utf-8").then(applyconf, function(){}); })
    .then(function() {
      var defer = Q.defer();
      fs.exists(emptyc.config.plugin_dir, defer.resolve);
      return defer.promise;
    })
    .then(function(exists) {
      if (exists)
      {
        modules = dire(emptyc.config.plugin_dir, true, '.js');
        return Q.all(Object.keys(modules).map(function(key) {
          if (modules[key].cache)
          {
            var fkey = key.replace(/\//g, '.') + ".json";
            var fpath = path.join(cachepath, fkey);
            modules[key].cache.path = fpath;
            if (fs.existsSync(fpath))
              modules[key].cache.data = JSON.parse(fs.readFileSync(fpath, "utf-8"));
          }
          if (modules[key].fini)
            finalizers.push(modules[key].fini.bind(modules[key]));
          if (modules[key].init)
            return modules[key].init(emptyc);
          else
            return Q.resolve();
        }));
      }
      else
      {
        console.log("Missing %s", emptyc.config.plugin_dir);
        return Q.resolve();
      }
    })
    .then(function() {
      var fpath = path.join(cachepath, "emptyc.json");
      emptyc.cache.path = fpath;
      if (fs.existsSync(fpath))
        emptyc.cache.data = JSON.parse(fs.readFileSync(fpath, "utf-8"));
      return Q.resolve();
    })
    .then(function() {
      process.title = path.basename(__filename, ".js");
      return Q.resolve();
    })
    .then(Q.all(emptyc.hooks.start))
    .then(emptyc.start.bind(emptyc))
    .then(function() {
      finalizers.forEach(function(f) { f(emptyc); });
      return Q.all(emptyc.hooks.exit)
    })
    .then(function() {
      for(var key in modules)
      {
        if (modules[key].cache && modules[key].cache.path)
          fs.writeFileSync(modules[key].cache.path, JSON.stringify(modules[key].cache.data));
      }
      fs.writeFileSync(emptyc.cache.path, JSON.stringify(emptyc.cache.data));
      return Q.resolve();
    })
    .then(emptyc.commands.exit.bind(emptyc))
    .then(function() { process.exit(0) })
    .done();
}());
